.. currentmodule:: control

State Space Analysis and Design
===============================

This section describes the functions the are available to analyze
state space systems and design state feedback controllers.  The
functionality described here is mainly specific to state space system
representations; additional functions for analysis of linear
input/output systems are defined in the next section and can also be
applied to LTI systems in state space form.


State space properties
----------------------

The following basic attributes and methods are available for
:class:`StateSpace` objects:

.. autosummary::

   ~StateSpace.A
   ~StateSpace.B
   ~StateSpace.C
   ~StateSpace.D
   ~StateSpace.dt
   ~StateSpace.shape
   ~StateSpace.nstates
   ~StateSpace.poles
   ~StateSpace.zeros
   ~StateSpace.dcgain
   ~StateSpace.sample
   ~StateSpace.returnScipySignalLTI
   ~StateSpace.__call__

A complete list of attributes, methods, and properties is available in
the :class:`StateSpace` class documentation.


Similarity transformations and canonical forms
----------------------------------------------

State space systems can be transformed into different internal
representations representing a variety of standard cananonical forms
that have the same input/output properties.  The
:func:`similarity_transform` function allows a change of internal
state variable via similarity transformation and the
:func:`canonical_form` function converts systems into different
canonical forms.  Additional information is available on the
documentation pages for the individual functions:

.. autosummary::

   canonical_form
   observable_form
   modal_form
   reachable_form
   similarity_transform


Time domain properties
----------------------

The following functions are available to analyze the time domain
properties of a linear system:

.. autosummary::

   damp
   forced_response
   impulse_response
   initial_response
   ssdata
   step_info
   step_response

The time response functions (:func:`impulse_response`,
:func:`initial_response`, :func:`forced_response`, and
:func:`step_response`) are described in more detail in the
:ref:`response-chapter` chapter.


State feedback design
---------------------

State feedback controllers for a linear system are controllers of the form

.. math::

   u = -K x

where :math:`K \in {\mathbb R}^{m \times n}` is a matrix of feedback
gains.  Assuming the systems is controllable, the resulting closed
loop system will have dynamics matrix :math:`A - B K` with stable
eigenvalues.

Feedback controllers can be designed using one of several
methods:

.. autosummary::

   lqr
   place
   place_acker
   place_varga

The :func:`place`, :func:`place_acker`, and :func:`place_varga` functions
place the eigenvalues of the closed loop system to a desired set of
values.  Each takes the `A` and `B` matrices of the state space system
and the desired location of the eigenvalues and returns a gain matrix
`K`::

  K = ct.place(sys.A, sys.B, E)

where `E` is a 1D array of desired eigenvalues.

The :func:`lqr` function computes the optimal state feedback controller
that minimizes the quadratic cost

.. math::

   J = \int_0^\infty (x' Q x + u' R u + 2 x' N u) dt

by solving the approriate Riccati equation.  It returns the gain
matrix `K`, the solution to the Riccati equation `S`, and the location
of the closed loop eigenvalues `E`.  It can be called in one of
several forms:

  * ``K, S, E = ct.lqr(sys, Q, R)``
  * ``K, S, E = ct.lqr(sys, Q, R, N)``
  * ``K, S, E = ct.lqr(A, B, Q, R)``
  * ``K, S, E = ct.lqr(A, B, Q, R, N)``

If :code:`sys` is a discrete-time system, the first two forms will compute
the discrete-time optimal controller.  For the second two forms, the
:func:`dlqr` function can be used to compute the discrete-time optimal
controller.  Additional arguments and details are given on the
:func:`lqr` and :func:`dlqr` documentation pages.

State estimation
----------------

State estimators (or observers) are dynamical systems that estimate
the state of a system given a model of the dynamics and the input
and output signals as a function of time.  Linear state estimators
have the form

.. math::

     \frac{d\hat x}{dt} = A \hat x + B u + L(y - C\hat x - D u),

where :math:`\hat x` is an estimate of the state and :math:`L \in
{\mathbb R}^{n \times p}` represents the estimator gain.  The gain
:math:`L` is chosen such that the eigenvalues of the matrix :math:`A -
L C` are stable, resulting in an estimate that converges to the value
of the system state.

The gain matrix :math:`L` can be chosen using eigenvalue placement by
calling the :func:`place` function::

  L = ct.place(sys.A.T, sys.C.T, E).T

where `E` is the desired location of the eigenvalues and ``.T`` computes
the transpose of a matrix.

More sophisticated estimators can be constructed by modeling noise and
disturbances as stochastic signals generated by a random process.
Estimators constructed using these models are described in more detail
in the :ref:`kalman-filter` section of the :ref:`stochastic-systems`
chapter.
